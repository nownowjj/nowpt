(function () {
'use strict';

let _root;
try {
  _root = window;
} catch (err) {
  _root = global;
}

var _root$1 = _root;

const getClass = obj => ({}.toString.call(obj).slice(8, -1));

const isFunction = obj => getClass(obj) === 'Function';
const isNumber = obj => getClass(obj) === 'Number';
const isString = obj => getClass(obj) === 'String';
const isBoolean = obj => getClass(obj) === 'Boolean';

function runPredicate(predicate) {
  if (isFunction(predicate)) {
    try {
      let result = predicate();
      if (!isBoolean(result)) {
        return false;
      }
      return result;
    } catch (err) {
      return false;
    }
  }

  throw new Error('Argument is not predicate function!');
}

function waitState(
  predicate,
  cb,
  timeout = _root$1.__defaultTimeout,
  refreshTime = _root$1.__defaultRefreshTime,
  startTime = Date.now()
) {
  if (!isFunction(predicate)) {
    throw new Error('First argument of waitState is not predicate!');
  }

  if (!isFunction(cb)) {
    throw new Error('Second argument of waitState is not function!');
  }

  if (timeout < refreshTime) {
    console.warn('Warning: Timeout argument less then refreshTime argument!');
  }

  if (runPredicate(predicate)) {
    return cb(null);
  } else {
    if (Date.now() - startTime > timeout) {
      return cb(new Error('Timeout in waitState occurred!'));
    }

    setTimeout(
      waitState,
      refreshTime,
      predicate,
      cb,
      timeout,
      refreshTime,
      startTime
    );
  }
}

function checkFoundElement(element, selectorForError) {
  if (element != null) {
    return true;
  }

  throw new Error("Can't find element, selector = " + selectorForError);
}

function findElement(selectorOrElement, timeoutOrCb, cb) {
  if (!selectorOrElement) {
    throw new Error(
      'first argument of findElement() undefined, it must be css selector!'
    );
  }

  let secondArgumentErrorMessage =
    'second argument of findElement() must be timeout number or a callback function!';
  if (!timeoutOrCb) {
    throw new Error(secondArgumentErrorMessage);
  }

  if (!isFunction(timeoutOrCb) && !isNumber(timeoutOrCb)) {
    throw new Error(secondArgumentErrorMessage);
  }

  if (isFunction(timeoutOrCb)) {
    return findElementNormalized(
      selectorOrElement,
      _root$1.__defaultTimeout,
      timeoutOrCb
    );
  }

  if (isNumber(timeoutOrCb)) {
    return findElementNormalized(selectorOrElement, timeoutOrCb, cb);
  }
}

function findElementNormalized(selectorOrElement, timeout, cb) {
  if (selectorOrElement.nodeType) {
    return cb(null, selectorOrElement);
  }

  let foundElement;
  waitState(
    () => {
      foundElement = document.querySelector(selectorOrElement);
      return checkFoundElement(foundElement);
    },
    () => cb(null, foundElement),
    timeout
  );
}

// this wrapper cannot handle function with many results,
// cause promise can pass only one of them to resolve function
function wrap(func) {
  return function(...funcArgs) {
    return new Promise((resolve, reject) => {
      func(...funcArgs, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      });
    });
  };
}

function simpleThrowerCallback(err) {
  if (err) throw err;
}

function directClick(selectorOrElement, cb = simpleThrowerCallback) {
  if (!selectorOrElement) {
    throw new Error('selector argument is not defined');
  }

  findElement(selectorOrElement, (err, element) => {
    if (err) {
      return cb(err);
    }

    element.click();
    return cb(null);
  });
}

/**
 * @param {string|Element} target - target element or its selector
 */
function click(target, cb = simpleThrowerCallback) {
  if (!target) {
    throw new Error('selector argument is not defined');
  }

  findElement(target, (err, elem) => {
    if (err) {
      return cb(err);
    }

    let clickEvent = new Event('click', {bubbles: true, cancelable: true});
    elem.dispatchEvent(clickEvent);
    return cb(null);
  });
}

/**
 * @param {string} options.type - event name e.g. "click"
 * @param {string|Element} options.target - target element or its selector
 */
function event(
  {type, target, bubbles = true, cancelable = true},
  cb = simpleThrowerCallback
) {
  if (!type) {
    throw new Error('event name argument is not defined');
  }

  if (!target) {
    throw new Error('target selector argument is not defined');
  }

  findElement(target, (err, elem) => {
    if (err) {
      return cb(err);
    }

    let eventOptions = {
      bubbles,
      cancelable
    };
    let event = new Event(type, eventOptions);
    elem.dispatchEvent(event);
    return cb(null);
  });
}

/**
 * @param {string|Element} targetInput - target input element or its selector
 */
function focusOn(targetInput, cb = simpleThrowerCallback) {
  if (!targetInput) {
    throw new Error('inputSelector argument is not defined');
  }

  findElement(targetInput, (err, elem) => {
    if (err) {
      return cb(err);
    }

    elem.focus();
    return cb(null);
  });
}

/**
 * @param {string|Element} target - target element or its selector
 */
function blur(target, cb = simpleThrowerCallback) {
  if (!target) {
    throw new Error('selector argument is not defined');
  }

  findElement(target, (err, elem) => {
    if (err) {
      return cb(err);
    }

    elem.blur();
    return cb(null);
  });
}

function changeValue(
  selectorOrElement,
  newValue,
  cb = simpleThrowerCallback
) {
  if (!selectorOrElement) {
    throw new Error('selector argument is not defined');
  }

  findElement(selectorOrElement, (err, inputElement) => {
    if (err) {
      return cb(err);
    }

    inputElement.value = newValue;
    return cb(null);
  });
}

/**
 * @param {Number | String} option - number or value or innerHTML
 */
function pickInSelect(
  selectSelectorOrElement,
  option,
  cb = simpleThrowerCallback
) {
  findElement(selectSelectorOrElement, (err, selectElement) => {
    if (err) return cb(err);

    let valueOptions = [];
    let innerHtmlOptions = [];
    for (let i = 0; i < selectElement.options.length; i++) {
      valueOptions.push(selectElement.options[i].value);
      innerHtmlOptions.push(selectElement.options[i].innerHTML);
    }

    if (valueOptions.length < 1) {
      // i leave ${string} cast even if selectSelectorOrElement will be
      // an element by design or by laziness.
      // QA-developer anyway will see problem in stacktrace
      throw new Error(`select ${selectSelectorOrElement} has no options`);
    }

    if (isString(option)) {
      if (valueOptions.includes(option)) {
        selectElement.value = option;
        return cb(null);
      }

      for (let i = 0; i < innerHtmlOptions.length; i++) {
        if (innerHtmlOptions[i] === option) {
          selectElement.value = valueOptions[i];
          return cb(null);
        }
      }

      return cb(
        new Error(
          `select ${selectSelectorOrElement} not contains ${option} option`
        )
      );
    }

    if (isNumber(option)) {
      if (option < 0) {
        return cb(
          new Error(`in ${selectSelectorOrElement}: your option is less then 0`)
        );
      }

      if (option >= valueOptions.length) {
        return cb(
          new Error(
            `in ${selectSelectorOrElement}: you selected ${option}, but max number is ${valueOptions.length -
              1}`
          )
        );
      }

      selectElement.value = valueOptions[option];
      return cb(null);
    }

    return cb(new Error('option parameter is not string or number'));
  });
}

_root$1.__defaultTimeout = 2000;
_root$1.__defaultRefreshTime = 300;

function setDefaultTimeout(timeout) {
  _root$1.__defaultTimeout = timeout;
}

function setDefaultRefreshTime(refreshTime) {
  _root$1.__defaultRefreshTime = refreshTime;
}

function getText(selectorOrElement, cb) {
  findElement(selectorOrElement, (err, element) => {
    let result = element.innerText || element.textContent;
    return cb(null, result);
  });
}

function getValue(selectorOrElement, cb) {
  findElement(selectorOrElement, (err, element) => {
    let result = element.value;
    return cb(null, result);
  });
}

let actionsModule = {};

actionsModule.promised = {};

actionsModule.directClick = directClick;
actionsModule.promised.directClick = wrap(directClick);

actionsModule.click = click;
actionsModule.promised.click = wrap(click);

actionsModule.event = event;
actionsModule.promised.event = wrap(event);

actionsModule.changeValue = changeValue;
actionsModule.promised.changeValue = wrap(changeValue);

actionsModule.focusOn = focusOn;
actionsModule.promised.focusOn = wrap(focusOn);

actionsModule.blur = blur;
actionsModule.promised.blur = wrap(blur);

actionsModule.pickInSelect = pickInSelect;
actionsModule.promised.pickInSelect = wrap(pickInSelect);

actionsModule.getText = getText;
actionsModule.promised.getText = wrap(getText);

actionsModule.getValue = getValue;
actionsModule.promised.getValue = wrap(getValue);

actionsModule.findElement = findElement;
actionsModule.promised.findElement = wrap(findElement);

actionsModule.waitState = waitState;
actionsModule.promised.waitState = function(
  predicate,
  timeout = _root$1.__defaultTimeout,
  refreshTime = _root$1.__defaultRefreshTime
) {
  return new Promise((resolve, reject) => {
    waitState(
      predicate,
      err => {
        if (err) {
          return reject(err);
        }

        return resolve();
      },
      timeout,
      refreshTime
    );
  });
};

actionsModule.runPredicate = runPredicate;
actionsModule.setDefaultRefreshTime = setDefaultRefreshTime;
actionsModule.setDefaultTimeout = setDefaultTimeout;

var version = "0.7.0";

function getVersion() {
  return `UserActions: ${version}`;
}

actionsModule.version = getVersion;
actionsModule.getVersion = getVersion;

window.userActions = actionsModule;
window.useractions = actionsModule;

}());
